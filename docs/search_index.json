[["index.html", "Salinity and Germination for 3 native species and invasive Phragmites australis Overview", " Salinity and Germination for 3 native species and invasive Phragmites australis Maddie Houde 2023-04-26 Overview This bookdown shares Sandra Johnstons undergraduate research experiment results. We walk through the directory structure, share visuals of raw data, and analyze the results of imposing higher salinities on species germination. "],["database-structure.html", "Chapter 1 Database Structure 1.1 Describing the relational structures in Sandra Johnstons 2023 Greenhouse Experiment. 1.2 Build database tables 1.3 Read our CSV files and connect them", " Chapter 1 Database Structure 1.1 Describing the relational structures in Sandra Johnstons 2023 Greenhouse Experiment. In this section, I will describe the relational data structure used in Sandras 2023 Greenhouse experiment. I will then create a SQL database to establish these .csv connections. To begin - here is a photo showing the 3 main .csv files used in this research project and the ways in which they connect. Figure 1.1: Figure 1. Database Structure Sample_Location describes the Species, Treatment, and Location of the 48 samples in this research project. Germination lists germination counts taken every 3rd day for each sample for the length of the experiment. Germination relates to Sample_Location through the foreign key Species_Tmt_Pos. EC_Final shows the final soil salinity for each sample taken from the top and bottom of the sample pots. EC_Final relates to Sample_Location through the foreign key Species_Tmt_Pos. 1.2 Build database tables Here, I load the package, then I create a database and connect to it in the same line of code using dbConnect. library(DBI) ## Warning: package &#39;DBI&#39; was built under R version 4.1.3 Sandra_db &lt;- dbConnect(RSQLite::SQLite(), &quot;~/Experiments_R/Sandra_GH_2023/Sandra_db.db&quot;) Since we already created this database in an .R script, we will first delete any existing tables. dbExecute(Sandra_db, &quot;DROP TABLE Germination;&quot;) ## [1] 0 dbExecute(Sandra_db, &quot;DROP TABLE EC_Final;&quot;) ## [1] 0 dbExecute(Sandra_db, &quot;DROP TABLE Sample_Location;&quot;) ## [1] 0 Now we will build the Sample_Location table. dbExecute(Sandra_db, &quot;CREATE TABLE Sample_Location ( Species_Tmt_Pos varchar(15) NOT NULL, Species char(4) NOT NULL, Column integer(1) NOT NULL, Row integer(1) NOT NULL, Salinity varchar(5) NOT NULL, PRIMARY KEY(Species_Tmt_Pos) );&quot;) ## [1] 0 Next, we will build the Germination table. dbExecute(Sandra_db, &quot;CREATE TABLE Germination ( auto_id integer PRIMARY KEY AUTOINCREMENT, Species char(4) NOT NULL, Column integer(1) NOT NULL, Row integer(1) NOT NULL, Salinity varchar(5) NOT NULL, Date varchar(10) NOT NULL, Emergence integer NOT NULL, Observer char(2) NOT NULL, Notes varchar(150) NOT NULL, Checked_by char(2) NOT NULL, Species_Tmt_Pos varchar(15) NOT NULL, FOREIGN KEY (Species_Tmt_Pos) REFERENCES Sample_Location(Species_Tmt_Pos) );&quot;) ## [1] 0 Last, we will build the EC_Final table. dbExecute(Sandra_db, &quot;CREATE TABLE EC_Final( auto_id integer PRIMARY KEY AUTOINCREMENT, Sample varchar(8) NOT NULL, Start_Time varchar(12) NOT NULL, Soil_Weight_g double(10) NOT NULL, Water_Rate_mL double(10) NOT NULL, Time_of_Measurement varchar(12) NOT NULL, EC_microS_cm integer(6) NOT NULL, PSU double(4) NOT NULL, Temperature_C double(4) NOT NULL, ECe_microS_cm double(15) NOT NULL, ECe_dS_m double(4) NOT NULL, PSU_e double(4) NOT NULL, Target_Salinity varchar(5) NOT NULL, premeasure varchar(75), Species_Tmt_Pos varchar(15) NOT NULL, FOREIGN KEY (Species_Tmt_Pos) REFERENCES Sample_Location(Species_Tmt_Pos) );&quot;) ## [1] 0 Lets check these tables using dbGetQuery to ensure they meet our needs. dbGetQuery(Sandra_db, &quot;SELECT * FROM Sample_Location;&quot;) ## [1] Species_Tmt_Pos Species Column Row ## [5] Salinity ## &lt;0 rows&gt; (or 0-length row.names) dbGetQuery(Sandra_db, &quot;SELECT * FROM Germination;&quot;) ## [1] auto_id Species Column Row ## [5] Salinity Date Emergence Observer ## [9] Notes Checked_by Species_Tmt_Pos ## &lt;0 rows&gt; (or 0-length row.names) dbGetQuery(Sandra_db, &quot;SELECT * FROM EC_Final;&quot;) ## [1] auto_id Sample Start_Time ## [4] Soil_Weight_g Water_Rate_mL Time_of_Measurement ## [7] EC_microS_cm PSU Temperature_C ## [10] ECe_microS_cm ECe_dS_m PSU_e ## [13] Target_Salinity premeasure Species_Tmt_Pos ## &lt;0 rows&gt; (or 0-length row.names) 1.3 Read our CSV files and connect them Lets read in all of our .csv files. Sample_Location &lt;- read.csv(&quot;../Raw_Data/Sample_Location.csv&quot;) Germination &lt;- read.csv(&quot;../Raw_Data/Germination.csv&quot;) EC_Final &lt;- read.csv(&quot;../Raw_Data/EC_Final.csv&quot;) Now, we need to ensure that the column names match exactly the naming convention and order of the SQL tables. We will do this through the head() command, and then rearrange the columns as needed. head(Germination, 2) ## Species Column Row Salinity Date Emergence Observer ## 1 PHAU 1 1 Fresh 1/30/23 0 MH ## 2 SARU 1 1 Fresh 1/30/23 0 MH ## Notes ## 1 day 3 of exp. Water EC logged on probe. in col 1 grouping 1 (row 1), I logged SARU, then a mistake remove (potentially wrong spp), then correct remark for ALOC. Delete this middle rmeark. -MH ## 2 ## Checked_by Species_Tmt_Pos ## 1 SJ PHAU_Fresh_C1R1 ## 2 SJ SARU_Fresh_C1R1 Germination$auto_id &lt;- 1:nrow(Germination) Germination &lt;- Germination[, c(11, 1:10)] head(EC_Final, 2) ## Sample Species_Tmt_Pos Start_Time Soil_Weight_g Water_Rate_mL ## 1 SM-C-B2 1:24:00 PM 4.517 22.58 ## 2 C2-R3-DT DISP_40_C2R3 1:57:00 PM 10.304 51.52 ## Time_of_Measurement EC_microS_cm PSU Temperature_C ECe_microS_cm ECe_dS_m ## 1 1:33:00 PM 2660 NA NA NA ## 2 1:59:00 PM 27450 16.8 15.64 40406.4 40.41 ## PSU_e Target_Salinity premeasure ## 1 NA Adriennes ## 2 24.73 40 20210 micS/cm, 11.41 psu, na EC_Final &lt;- EC_Final[, c(1, 3:14, 2)] The EC_Final data is not entirely filled in yet. We will omit any rows with NA for the purposes of this assignment. EC_Final &lt;- na.omit(EC_Final) Now that our .csv files are neat and tidy, we can connect them to our database tables. dbWriteTable(Sandra_db, &quot;Germination&quot;, Germination, append = TRUE) dbWriteTable(Sandra_db, &quot;EC_Final&quot;, EC_Final, append = TRUE) dbWriteTable(Sandra_db, &quot;Sample_Location&quot;, Sample_Location, append = TRUE) As always, double check your work. dbGetQuery(Sandra_db, &quot;SELECT * FROM Sample_Location LIMIT 5;&quot;) ## Species_Tmt_Pos Species Column Row Salinity ## 1 PHAU_Fresh_C1R1 PHAU 1 1 Fresh ## 2 SARU_Fresh_C1R1 SARU 1 1 Fresh ## 3 DISP_Fresh_C1R1 DISP 1 1 Fresh ## 4 ALOC_Fresh_C1R1 ALOC 1 1 Fresh ## 5 PHAU_40_C1R2 PHAU 1 2 40 dbGetQuery(Sandra_db, &quot;SELECT * FROM Germination LIMIT 5;&quot;) ## auto_id Species Column Row Salinity Date Emergence Observer ## 1 1 PHAU 1 1 Fresh 1/30/23 0 MH ## 2 2 SARU 1 1 Fresh 1/30/23 0 MH ## 3 3 DISP 1 1 Fresh 1/30/23 0 MH ## 4 4 ALOC 1 1 Fresh 1/30/23 0 MH ## 5 5 PHAU 1 2 40 1/30/23 0 MH ## Notes ## 1 day 3 of exp. Water EC logged on probe. in col 1 grouping 1 (row 1), I logged SARU, then a mistake remove (potentially wrong spp), then correct remark for ALOC. Delete this middle rmeark. -MH ## 2 ## 3 ## 4 ## 5 ## Checked_by Species_Tmt_Pos ## 1 SJ PHAU_Fresh_C1R1 ## 2 SJ SARU_Fresh_C1R1 ## 3 SJ DISP_Fresh_C1R1 ## 4 SJ ALOC_Fresh_C1R1 ## 5 SJ PHAU_40_C1R2 dbGetQuery(Sandra_db, &quot;SELECT * FROM EC_Final LIMIT 5;&quot;) ## auto_id Sample Start_Time Soil_Weight_g Water_Rate_mL Time_of_Measurement ## 1 1 C2-R3-DT 1:57:00 PM 10.304 51.52 1:59:00 PM ## 2 2 C1-R4-ST 2:18:00 PM 7.778 38.90 2:45:00 PM ## 3 3 C1-R4-SB 2:21:00 PM 7.297 36.45 2:51:00 PM ## 4 4 C3-R4-AB 2:25:00 PM 8.166 40.83 2:53:00 PM ## 5 5 C3-R4-AT 2:27:00 PM 8.196 40.98 2:56:00 PM ## EC_microS_cm PSU Temperature_C ECe_microS_cm ECe_dS_m PSU_e Target_Salinity ## 1 27450 16.80 15.64 40406.40 40.41 24.73 40 ## 2 46170 29.99 15.53 51314.66 51.31 33.33 40 ## 3 46330 30.02 15.81 48249.39 48.25 31.26 40 ## 4 39840 25.34 16.05 46476.21 46.48 29.56 25 ## 5 22060 13.34 15.70 25829.11 25.83 15.62 25 ## premeasure Species_Tmt_Pos ## 1 20210 micS/cm, 11.41 psu, na DISP_40_C2R3 ## 2 16510 micS/cm, 9.63 psu, 20.51 C SARU_40_C1R4 ## 3 24170 micS/cm, 1475 psu, 20.76 C SARU_40_C1R4 ## 4 17190 micS/cm, 10.04 psu, 21.14 C ALOC_25_C3R4 ## 5 13680 micS/cm, 7.93 psu, 20.28 C ALOC_25_C3R4 "],["data-wrangling.html", "Chapter 2 Data Wrangling 2.1 Load required R packages and raw data 2.2 Changing column class 2.3 Explore the data frame 2.4 Adding a column 2.5 Removing (filtering) data 2.6 Changing incorrect data 2.7 Save your data object for future use", " Chapter 2 Data Wrangling In this chapter, I take a raw .CSV file and use data wrangling techniques to prepare it for future analysis and graphing. 2.1 Load required R packages and raw data I first need to clean up the data from the greenhouse experiment and get it into a logical order. Lets begin! # Load required packages library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 4.1.3 ## -- Attaching packages ---------------------------------------- tidyverse 1.3.2 -- ## v ggplot2 3.4.0 v purrr 1.0.0 ## v tibble 3.1.8 v dplyr 1.0.10 ## v tidyr 1.2.1 v stringr 1.5.0 ## v readr 2.1.3 v forcats 0.5.2 ## Warning: package &#39;ggplot2&#39; was built under R version 4.1.3 ## Warning: package &#39;tibble&#39; was built under R version 4.1.3 ## Warning: package &#39;tidyr&#39; was built under R version 4.1.3 ## Warning: package &#39;readr&#39; was built under R version 4.1.3 ## Warning: package &#39;purrr&#39; was built under R version 4.1.3 ## Warning: package &#39;dplyr&#39; was built under R version 4.1.3 ## Warning: package &#39;stringr&#39; was built under R version 4.1.3 ## Warning: package &#39;forcats&#39; was built under R version 4.1.3 ## -- Conflicts ------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() # Load our data setwd(&quot;../Raw_Data&quot;) Germ &lt;- read.csv(&quot;Germination.csv&quot;, header=T) head(Germ) ## Species Column Row Salinity Date Emergence Observer ## 1 PHAU 1 1 Fresh 1/30/23 0 MH ## 2 SARU 1 1 Fresh 1/30/23 0 MH ## 3 DISP 1 1 Fresh 1/30/23 0 MH ## 4 ALOC 1 1 Fresh 1/30/23 0 MH ## 5 PHAU 1 2 40 1/30/23 0 MH ## 6 SARU 1 2 40 1/30/23 0 MH ## Notes ## 1 day 3 of exp. Water EC logged on probe. in col 1 grouping 1 (row 1), I logged SARU, then a mistake remove (potentially wrong spp), then correct remark for ALOC. Delete this middle rmeark. -MH ## 2 ## 3 ## 4 ## 5 ## 6 ## Checked_by Species_Tmt_Pos ## 1 SJ PHAU_Fresh_C1R1 ## 2 SJ SARU_Fresh_C1R1 ## 3 SJ DISP_Fresh_C1R1 ## 4 SJ ALOC_Fresh_C1R1 ## 5 SJ PHAU_40_C1R2 ## 6 SJ SARU_40_C1R2 # Drop columns we don&#39;t need Germ &lt;- Germ[ , -c(7, 8, 9)] Tidyverse can be a clearer way to drop columns. For example, we could have written: Germ &lt;- Germ %&gt;% select(-c(Observer:Checked_by)) and gotten the same result. 2.2 Changing column class We need to ensure R is reading our data how we would like. Typically, this requires changing the column class by specifying what format our data is in. But to do that - we need to know what class our data currently is! # View default class sapply(Germ, class) ## Species Column Row Salinity Date ## &quot;character&quot; &quot;integer&quot; &quot;integer&quot; &quot;character&quot; &quot;character&quot; ## Emergence Species_Tmt_Pos ## &quot;integer&quot; &quot;character&quot; We would like Species, Column, Row, Salinity, and Species_Tmt_Pos to be classed as factors. Additionally, we want our Date column to be classed as a date. # A slow way to change column class is to call each column directly, like below Germ$Species &lt;- as.factor(Germ$Species) class(Germ$Species) ## [1] &quot;factor&quot; # Here is a faster way to change multiple column classes # Create a vector containing all of our future factor column names factor_cols &lt;- c(&quot;Species&quot;, &quot;Column&quot;, &quot;Row&quot;, &quot;Salinity&quot;, &quot;Species_Tmt_Pos&quot;) # Use baseR functions to change all of these columns in one line of code Germ[factor_cols]&lt;-lapply(Germ[factor_cols], as.factor) Dates are a special kind of class in R. We can use library(lubridate) to set this up. # View how our dates are written head(Germ, 2) ## Species Column Row Salinity Date Emergence Species_Tmt_Pos ## 1 PHAU 1 1 Fresh 1/30/23 0 PHAU_Fresh_C1R1 ## 2 SARU 1 1 Fresh 1/30/23 0 SARU_Fresh_C1R1 # These are written in mm dd yy format, so we can use the lubridate function mdy() # to change the class Germ$Date &lt;- lubridate::mdy(Germ$Date) Great! We should have our classes all in the right order now! Lets check sapply(Germ, class) ## Species Column Row Salinity Date ## &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; &quot;Date&quot; ## Emergence Species_Tmt_Pos ## &quot;integer&quot; &quot;factor&quot; 2.3 Explore the data frame Now we take a birds eye view of our data frame and check for typos, reasonable values, and more. # How many rows is our data frame? length(Germ) ## [1] 7 # Do we have any NAs? and if so - where are they located in our dataframe? which(is.na(Germ)) ## integer(0) # View our min and max emergence to check for reasonable values # We could do this with baseR min(Germ$Emergence) ## [1] 0 max(Germ$Emergence) ## [1] 48 # or with Tidyverse Germ %&gt;% select(Emergence) %&gt;% max() ## [1] 48 # We can also check our factor levels to see if we have any typos, or unexpected # values, etc.. levels(Germ$Species) ## [1] &quot;ALOC&quot; &quot;DISP&quot; &quot;PHAU&quot; &quot;SARU&quot; levels(Germ$Salinity) ## [1] &quot;25&quot; &quot;40&quot; &quot;Fresh&quot; levels(Germ$Column) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(Germ$Row) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; # Alternatively, we can use a Lapply function to view levels of each factor column # at once! lapply(Germ, levels) ## $Species ## [1] &quot;ALOC&quot; &quot;DISP&quot; &quot;PHAU&quot; &quot;SARU&quot; ## ## $Column ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## ## $Row ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ## ## $Salinity ## [1] &quot;25&quot; &quot;40&quot; &quot;Fresh&quot; ## ## $Date ## NULL ## ## $Emergence ## NULL ## ## $Species_Tmt_Pos ## [1] &quot;ALOC_25_C1R3&quot; &quot;ALOC_25_C2R1&quot; &quot;ALOC_25_C3R2&quot; &quot;ALOC_25_C3R4&quot; ## [5] &quot;ALOC_40_C1R2&quot; &quot;ALOC_40_C1R4&quot; &quot;ALOC_40_C2R3&quot; &quot;ALOC_40_C3R1&quot; ## [9] &quot;ALOC_Fresh_C1R1&quot; &quot;ALOC_Fresh_C2R2&quot; &quot;ALOC_Fresh_C2R4&quot; &quot;ALOC_Fresh_C3R3&quot; ## [13] &quot;DISP_25_C1R3&quot; &quot;DISP_25_C2R1&quot; &quot;DISP_25_C3R2&quot; &quot;DISP_25_C3R4&quot; ## [17] &quot;DISP_40_C1R2&quot; &quot;DISP_40_C1R4&quot; &quot;DISP_40_C2R3&quot; &quot;DISP_40_C3R1&quot; ## [21] &quot;DISP_Fresh_C1R1&quot; &quot;DISP_Fresh_C2R2&quot; &quot;DISP_Fresh_C2R4&quot; &quot;DISP_Fresh_C3R3&quot; ## [25] &quot;PHAU_25_C1R3&quot; &quot;PHAU_25_C2R1&quot; &quot;PHAU_25_C3R2&quot; &quot;PHAU_25_C3R4&quot; ## [29] &quot;PHAU_40_C1R2&quot; &quot;PHAU_40_C1R4&quot; &quot;PHAU_40_C2R3&quot; &quot;PHAU_40_C3R1&quot; ## [33] &quot;PHAU_Fresh_C1R1&quot; &quot;PHAU_Fresh_C2R2&quot; &quot;PHAU_Fresh_C2R4&quot; &quot;PHAU_Fresh_C3R3&quot; ## [37] &quot;SARU_25_C1R3&quot; &quot;SARU_25_C2R1&quot; &quot;SARU_25_C3R2&quot; &quot;SARU_25_C3R4&quot; ## [41] &quot;SARU_40_C1R2&quot; &quot;SARU_40_C1R4&quot; &quot;SARU_40_C2R3&quot; &quot;SARU_40_C3R1&quot; ## [45] &quot;SARU_Fresh_C1R1&quot; &quot;SARU_Fresh_C2R2&quot; &quot;SARU_Fresh_C2R4&quot; &quot;SARU_Fresh_C3R3&quot; 2.4 Adding a column Our dataframe includes monitoring date, but it would be more intuitive if we had a column that specified experiment day rather than date. Lets add one. # View how many unique dates we recorded emergence unique(Germ$Date) ## [1] &quot;2023-01-30&quot; &quot;2023-02-02&quot; &quot;2023-02-05&quot; &quot;2023-02-08&quot; &quot;2023-02-11&quot; ## [6] &quot;2023-02-14&quot; &quot;2023-02-17&quot; &quot;2023-02-20&quot; &quot;2023-02-23&quot; &quot;2023-02-27&quot; # Alternatively in tidyverse... Germ %&gt;% select(Date) %&gt;% distinct() ## Date ## 1 2023-01-30 ## 2 2023-02-02 ## 3 2023-02-05 ## 4 2023-02-08 ## 5 2023-02-11 ## 6 2023-02-14 ## 7 2023-02-17 ## 8 2023-02-20 ## 9 2023-02-23 ## 10 2023-02-27 # Add a column where 01-30 is day 3 of the experiment, and then continued.. Germ &lt;- Germ %&gt;% mutate(Day = dplyr::case_when( Date == &quot;2023-01-30&quot; ~ 3, Date == &quot;2023-02-02&quot; ~ 6, Date == &quot;2023-02-05&quot; ~ 9, Date == &quot;2023-02-08&quot; ~ 12, Date == &quot;2023-02-11&quot; ~ 15, Date == &quot;2023-02-14&quot; ~ 18, Date == &quot;2023-02-17&quot; ~ 21, Date == &quot;2023-02-20&quot; ~ 24, Date == &quot;2023-02-23&quot; ~ 27, Date == &quot;2023-02-27&quot; ~ 31)) 2.5 Removing (filtering) data Although we evaluated 4 species in this experiment, we need to remove Distichlis spicata, (or DISP), due to low emergence in all treatments. This species typically performs well in our experiments, so we assume that its low emergence was due to some issue with this particular seed lot. Germ &lt;- Germ %&gt;% filter(Species != &quot;DISP&quot;) 2.6 Changing incorrect data Last, we initially recorded 2 emergence counts for Salicornia rubra (SARU) at the 40 PPT salinity level. At a later date, we decided that the emergence was more likely the radicle unfurling with imbibition, but was not necessarily true emergence. To address this we will change the counts of emergence to 0 at these levels Germ$Emergence[Germ$Species == &quot;SARU&quot; &amp; Germ$Salinity == &quot;40&quot; &amp; Germ$Emergence != &quot;0&quot;] &lt;- 0 2.7 Save your data object for future use Whew! Now that weve gone through all this effort we can save the cleaned data object and simply load it for future coding use. getwd() setwd(&quot;../Processed_Data&quot;) save(Germ, file=&quot;DF_Germination.Rdata&quot;) list.files() "],["creating-visuals-with-our-dataset.html", "Chapter 3 Creating Visuals with our dataset 3.1 Load our previously cleaned dataset 3.2 Prepare dataset to create a graph showing cumulative germination counts 3.3 Cumulative Germination Graph 3.4 Cumulative Germination Graph", " Chapter 3 Creating Visuals with our dataset In this chapter, I will create a few graphs showing raw data results from the experiment. 3.1 Load our previously cleaned dataset getwd() ## [1] &quot;C:/Users/mhoud/Documents/Experiments_R/Sandra_GH_2023/Website_Reproducible-Data&quot; setwd(&quot;../Processed_Data&quot;) list.files() ## [1] &quot;Code_Germination.R&quot; &quot;DF_Germination-Fresh-25-Only.RData&quot; ## [3] &quot;DF_Germination.Rdata&quot; &quot;Germ_mean.Rdata&quot; ## [5] &quot;Model_object.RData&quot; load(&quot;DF_Germination.RData&quot;) We also want to load any required packages. We could call these individually, or we could simply load tidyverse library(tidyverse) 3.2 Prepare dataset to create a graph showing cumulative germination counts head(Germ) ## Species Column Row Salinity Date Emergence Species_Tmt_Pos Day ## 1 PHAU 1 1 Fresh 2023-01-30 0 PHAU_Fresh_C1R1 3 ## 2 SARU 1 1 Fresh 2023-01-30 0 SARU_Fresh_C1R1 3 ## 3 ALOC 1 1 Fresh 2023-01-30 0 ALOC_Fresh_C1R1 3 ## 4 PHAU 1 2 40 2023-01-30 0 PHAU_40_C1R2 3 ## 5 SARU 1 2 40 2023-01-30 0 SARU_40_C1R2 3 ## 6 ALOC 1 2 40 2023-01-30 0 ALOC_40_C1R2 3 Here, we can see that we have emergence counts for each species and salinity level, but these are not cumulative counts. We need to do several things. 1) create a cumulative emergence column 2) average across the species and salinity interaction, and 3) create a standard error of these values. # Create a standard error function std.error &lt;- function(x) sd(x)/sqrt(length(x)) Germ &lt;- Germ %&gt;% group_by(Species_Tmt_Pos) %&gt;% mutate(Total_Germination = cumsum(Emergence)) %&gt;% ungroup() %&gt;% mutate(Salinity = factor(Salinity, levels = c(&quot;Fresh&quot;, &quot;25&quot;, &quot;40&quot;))) %&gt;% group_by(Species, Salinity, Day) %&gt;% summarize(SE = std.error(Total_Germination), Total_Germination = mean(Total_Germination)) %&gt;% ungroup() %&gt;% as_tibble() ## `summarise()` has grouped output by &#39;Species&#39;, &#39;Salinity&#39;. You can override ## using the `.groups` argument. 3.3 Cumulative Germination Graph vec &lt;- c(&quot;darkblue&quot;, &quot;blue&quot;, &quot;lightblue&quot;) ggplot(Germ, aes(x = Day, y = Total_Germination, color = Species)) + geom_point(size = 4) + geom_line() + geom_linerange(ymin = Germ$Total_Germination - Germ$SE, ymax = Germ$Total_Germination + Germ$SE) + labs(title = &quot;Cumulative Germination&quot;, x = &quot;Monitoring Day&quot;, y = &quot;Mean Cumulative Germination ± SE&quot;) + theme(axis.title = element_text(size = 18), plot.title = element_text(size = 22, hjust = 0.5), legend.text = element_text(size = 16), legend.title = element_text(size = 18), ) + scale_color_manual(values = vec) + ylim(0, 100) + # Set 100 upper limit since that is what we seeded facet_wrap(~ Salinity) + theme_bw() Above we created a graph that was faceted by salinity. Now, we would like to facet by species to view species-specific tolerances to salinity. 3.4 Cumulative Germination Graph vec &lt;- c(&quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;) ggplot(Germ, aes(x = Day, y = Total_Germination, color = Salinity)) + geom_point(size = 4) + geom_line() + geom_linerange(ymin = Germ$Total_Germination - Germ$SE, ymax = Germ$Total_Germination + Germ$SE) + labs(title = &quot;Cumulative Germination&quot;, x = &quot;Monitoring Day&quot;, y = &quot;Mean Cumulative Germination ± SE&quot;) + theme(axis.title = element_text(size = 18), plot.title = element_text(size = 22, hjust = 0.5), legend.text = element_text(size = 16), legend.title = element_text(size = 18), ) + scale_color_manual(values = vec) + ylim(0, 100) + # Set 100 upper limit since that is what we seeded facet_wrap(~ Species) + theme_bw() "],["analyze-data.html", "Chapter 4 Analyze data 4.1 Load data. 4.2 Remove 40 PPT 4.3 Poisson model 4.4 Poisson model diagnostic plots 4.5 Negative binomial model 4.6 Fixed effects prior 4.7 Weaker fixed effects priors", " Chapter 4 Analyze data Weve now seen what our raw data looks like, and we have an idea that salinity had a significant effect on species germination. However, we would like to show that effect using a generalized linear mixed model. 4.1 Load data. Load packages too. library(tidyverse) #gives ggplot2 and piping library(glmmTMB) ## Warning: package &#39;glmmTMB&#39; was built under R version 4.1.3 ## Warning in checkMatrixPackageVersion(): Package version inconsistency detected. ## TMB was built with Matrix version 1.5.1 ## Current Matrix version is 1.5.3 ## Please re-install &#39;TMB&#39; from source using install.packages(&#39;TMB&#39;, type = &#39;source&#39;) or ask CRAN for a binary version of &#39;TMB&#39; matching CRAN&#39;s &#39;Matrix&#39; package library(car) ## Warning: package &#39;car&#39; was built under R version 4.1.3 ## Loading required package: carData ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode ## The following object is masked from &#39;package:purrr&#39;: ## ## some library(DHARMa) ## Warning: package &#39;DHARMa&#39; was built under R version 4.1.3 ## This is DHARMa 0.4.6. For overview type &#39;?DHARMa&#39;. For recent changes, type news(package = &#39;DHARMa&#39;) library(emmeans) ## Warning: package &#39;emmeans&#39; was built under R version 4.1.3 library(blme) ## Warning: package &#39;blme&#39; was built under R version 4.1.3 ## Loading required package: lme4 ## Warning: package &#39;lme4&#39; was built under R version 4.1.3 ## Loading required package: Matrix ## Warning: package &#39;Matrix&#39; was built under R version 4.1.3 ## ## Attaching package: &#39;Matrix&#39; ## The following objects are masked from &#39;package:tidyr&#39;: ## ## expand, pack, unpack We will analyze our data using total germination counts, and will likely use a Poisson distribution. To do that, we need to create a new column for total counts. We also want to add a new column which accounts for the location (or block) in the greenhouse. We will call this spot the Whole_Plot # Whole Plot Germ$Whole_Plot &lt;- as.factor(paste(Germ$Column, Germ$Row)) # Total Emergence Germ &lt;- Germ %&gt;% dplyr::group_by(Species, Salinity, Whole_Plot) %&gt;% dplyr::summarise(Total_Emergence = sum(Emergence)) %&gt;% dplyr::ungroup() ## `summarise()` has grouped output by &#39;Species&#39;, &#39;Salinity&#39;. You can override ## using the `.groups` argument. 4.2 Remove 40 PPT If you recall, the 40 PPT had zero germination counts. We recognize that this is a species tolerance limit for ALL of our species in this experiment. We wont gain any new information by including this in our analysis, so we remove it here. Germ &lt;- Germ %&gt;% filter(Salinity %in% c(&quot;Fresh&quot;, &quot;25&quot;)) %&gt;% mutate(Salinity = factor(Salinity, levels = c(&quot;Fresh&quot;, &quot;25&quot;))) We can check that we successfully removed 40 as a salinity factor. levels(Germ$Salinity) ## [1] &quot;Fresh&quot; &quot;25&quot; 4.3 Poisson model The first stab at model creation. G_Mod &lt;- glmmTMB(Total_Emergence ~ Species + Salinity + Species:Salinity + (1 | Whole_Plot), family = poisson, # count data data = Germ) 4.4 Poisson model diagnostic plots Lets see how this model fits by looking at residual plots and DHARMa diagnostics. Our model fit could be improved. The second plot shows us that our mean very likely does not equal our variance (as is assumed by a Poisson distribution). To address this, we can swap to a negative binomial distribution and see if the diagnostics improve. 4.5 Negative binomial model G_Mod &lt;- glmmTMB(Total_Emergence ~ Species + Salinity + Species:Salinity + (1 | Whole_Plot), family = nbinom1(), # quasi poisson data = Germ) Note that our model statement is exactly the same, with the exception of the family call. Lets look at those diagnostic plots. This looks better! Now I will explore the model further. The spread of residuals is improved here. We can also look at the salinity effect on our model estimates. The Salicornia rubra here has a highly negative prediction from Fresh to 25. This poses an issue when interpreting our data. It likely resulted from having zero germination at the 25 PPT salinity for SARU (as seen below). ## # A tibble: 4 x 4 ## Species Salinity Whole_Plot Total_Emergence ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 SARU 25 1 3 0 ## 2 SARU 25 2 1 0 ## 3 SARU 25 3 2 0 ## 4 SARU 25 3 4 0 We had 4 replicates, and you can see that each replicate had zero seeds emerge. Poisson and negative binomial distributions struggle with zero counts, because it has (1) no variance and (2) it exists right at the edge of the distributions range (0, infinity). We need to address this by adding a fixed effects prior to our model. Our model interpretation is meaningless as is, because the 0s can impact other model estimates. 4.6 Fixed effects prior Below we switch to using bglmer() rather than glmmTMB() because it allows us to add fixed effects priors. These are added to our model estimates, in the order of our model summary. To remind ourselves how many fixed effects we have, we can look at our summary. ## Family: nbinom1 ( log ) ## Formula: ## Total_Emergence ~ Species + Salinity + Species:Salinity + (1 | Whole_Plot) ## Data: Germ ## ## AIC BIC logLik deviance df.resid ## 136.7 146.1 -60.4 120.7 16 ## ## Random effects: ## ## Conditional model: ## Groups Name Variance Std.Dev. ## Whole_Plot (Intercept) 5.517e-16 2.349e-08 ## Number of obs: 24, groups: Whole_Plot, 8 ## ## Dispersion parameter for nbinom1 family (): 2.59 ## ## Conditional model: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.238e+00 1.132e-01 37.44 &lt; 2e-16 *** ## SpeciesPHAU -5.829e-03 1.598e-01 -0.04 0.97090 ## SpeciesSARU -2.559e+00 3.988e-01 -6.42 1.39e-10 *** ## Salinity25 -1.791e+00 3.027e-01 -5.92 3.26e-09 *** ## SpeciesPHAU:Salinity25 -3.121e+00 1.076e+00 -2.90 0.00374 ** ## SpeciesSARU:Salinity25 -1.933e+01 1.183e+04 0.00 0.99870 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 There are 6 fixed effects to account for. Also note that the estimate for SARU and its interaction with 25 PPT has a really large standard error (1.183e04). That number should change if we successfully adjust away from 0. G_Mod &lt;- bglmer(Total_Emergence ~ Species * Salinity + (1 | Whole_Plot), family = poisson(), # back to Poisson for now fixef.prior = normal(sd = c(3, 3, 3, 3, 3, 3)), data = Germ) Priors of 3 represent a reasonable value (2.5 is default). The larger number you have the less of an effect it makes on your data. Lets see if the standard error was adjusted. ## Cov prior : Whole_Plot ~ wishart(df = 3.5, scale = Inf, posterior.scale = cov, common.scale = TRUE) ## Fixef prior: normal(sd = c(3, 3, ...), corr = c(0 ...), common.scale = FALSE) ## Prior dev : 30.6443 ## ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [bglmerMod] ## Family: poisson ( log ) ## Formula: Total_Emergence ~ Species * Salinity + (1 | Whole_Plot) ## Data: Germ ## ## AIC BIC logLik deviance df.resid ## 138.8 147.0 -62.4 124.8 17 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.8141 -0.4300 -0.2502 0.4163 1.7269 ## ## Random effects: ## Groups Name Variance Std.Dev. ## Whole_Plot (Intercept) 0.4629 0.6804 ## Number of obs: 24, groups: Whole_Plot, 8 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.13865 0.34669 11.938 &lt; 2e-16 *** ## SpeciesPHAU -0.01159 0.08563 -0.135 0.892305 ## SpeciesSARU -2.61655 0.23045 -11.354 &lt; 2e-16 *** ## Salinity25 -1.78677 0.50523 -3.537 0.000405 *** ## SpeciesPHAU:Salinity25 -3.66333 0.82479 -4.442 8.93e-06 *** ## SpeciesSARU:Salinity25 -2.63018 1.58631 -1.658 0.097306 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) SpPHAU SpSARU Slnt25 SPHAU: ## SpeciesPHAU -0.120 ## SpeciesSARU -0.044 0.183 ## Salinity25 -0.645 0.080 0.029 ## SpcPHAU:S25 0.011 -0.096 -0.017 -0.047 ## SpcSARU:S25 0.004 -0.019 -0.105 -0.019 0.011 Now the standard error is 1.58, which is a lot more reasonable! However, we may not wish to penalize all of our fixed effects if SARU poses the only issue. In this case, we could use large numbers on effects where we want weak penalization, and use smaller numbers (e.g., 2.5) for our problem child. One more note that PHAU (Phragmites australis) also had low germination at 25 PPT. To account for this, I will penalize PHAU:25 as well. 4.7 Weaker fixed effects priors G_Mod &lt;- bglmer(Total_Emergence ~ Species * Salinity + (1 | Whole_Plot), family = poisson(), fixef.prior = normal(c(1e4, 1e4, 1e4, 1e4, 2.5, 2.5)), data = Germ) summary(G_Mod) ## Cov prior : Whole_Plot ~ wishart(df = 3.5, scale = Inf, posterior.scale = cov, common.scale = TRUE) ## Fixef prior: normal(sd = c(10000, 10000, ...), corr = c(0 ...), common.scale = FALSE) ## Prior dev : 92.4226 ## ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [bglmerMod] ## Family: poisson ( log ) ## Formula: Total_Emergence ~ Species * Salinity + (1 | Whole_Plot) ## Data: Germ ## ## AIC BIC logLik deviance df.resid ## 139.0 147.3 -62.5 125.0 17 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.7887 -0.4347 -0.2716 0.4346 1.5901 ## ## Random effects: ## Groups Name Variance Std.Dev. ## Whole_Plot (Intercept) 0.4624 0.68 ## Number of obs: 24, groups: Whole_Plot, 8 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.21924 0.34534 12.218 &lt; 2e-16 *** ## SpeciesPHAU -0.01653 0.08559 -0.193 0.846813 ## SpeciesSARU -2.63979 0.23294 -11.333 &lt; 2e-16 *** ## Salinity25 -1.90030 0.52414 -3.626 0.000288 *** ## SpeciesPHAU:Salinity25 -3.54285 0.77452 -4.574 4.78e-06 *** ## SpeciesSARU:Salinity25 -2.34789 1.37923 -1.702 0.088696 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) SpPHAU SpSARU Slnt25 SPHAU: ## SpeciesPHAU -0.123 ## SpeciesSARU -0.045 0.181 ## Salinity25 -0.659 0.080 0.029 ## SpcPHAU:S25 0.012 -0.100 -0.018 -0.048 ## SpcSARU:S25 0.005 -0.021 -0.118 -0.021 0.013 We can explore this model to assess model fit. ## Warning in checkModel(fittedModel): DHARMa: fittedModel not in class of ## supported models. Absolutely no guarantee that this will work! This model fit could be improved. Earlier, we fixed these issues by moving to a nbinom() distribution. Unfortunately, that is not possible when using fixed effects priors. However, lets take a step back and look at the raw data. ## `summarise()` has grouped output by &#39;Species&#39;, &#39;Salinity&#39;. You can override ## using the `.groups` argument. It is pretty clear from the above graph that salinity DID have an effect on species germination, and perhaps that we would expect differing magnitudes of reduction between species as we move from fresh to 25 ppt salinity. We shouldnt have to go to crazy efforts to prove what we already know by looking at our raw data. Not to mention - there is danger in applying complicated statistics when you cannot easily explain their purpose. With that said, we will go forward with the use of this model. Lets explore salinity effect with model estimates. These error bars are a lot more reasonable! Other exploration graphs Check for significance of fixed effects ## Analysis of Deviance Table (Type II Wald chisquare tests) ## ## Response: Total_Emergence ## Chisq Df Pr(&gt;Chisq) ## Species 138.712 2 &lt; 2.2e-16 *** ## Salinity 15.099 1 0.000102 *** ## Species:Salinity 23.627 2 7.405e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Yup, as expected: the interaction between species and salinity is significant. We can use emmeans to view real-world (back transformed) model estimates of species germination at each salinity level. ## Species = ALOC: ## Salinity rate SE df asymp.LCL asymp.UCL ## Fresh 67.9817 23.4766 Inf 34.5494 133.77 ## 25 10.1649 4.0090 Inf 4.6923 22.02 ## ## Species = PHAU: ## Salinity rate SE df asymp.LCL asymp.UCL ## Fresh 66.8669 23.0976 Inf 33.9769 131.59 ## 25 0.2893 0.2449 Inf 0.0550 1.52 ## ## Species = SARU: ## Salinity rate SE df asymp.LCL asymp.UCL ## Fresh 4.8523 1.9787 Inf 2.1819 10.79 ## 25 0.0693 0.0983 Inf 0.0043 1.12 ## ## Confidence level used: 0.95 ## Intervals are back-transformed from the log scale Whew! We did a lot of work here. Now that we know our interaction is significant, we can try to tease out which combination of effects are significant. However, that will have to wait for another chapter. See you soon! "],["drawing-further-inference.html", "Chapter 5 Drawing further inference 5.1 Pairwise comparison 5.2 Conclusions", " Chapter 5 Drawing further inference We now have a model that shows a significant interaction between salinity treatments and species. We will proceed with custom contrast statements to pinpoint what treatments, and what species differed significantly from each other. Lets load any required packages and our data. We want to specify contrasts between the REDUCTION in germination between the freshwater and the 25 ppt salinity treatment. To do that, we need to subtract the model estimate of total germination of the 25 ppt salinity level from the freshwater salinity level. We can do this using the emmeans object output. emm1 &lt;- emmeans(G_Mod2, ~ Salinity | Species) con1 &lt;- contrast(emm1, interaction = &quot;pairwise&quot;) The emm1 object here grabs the model estimates from our two salinity levels; the con1 object then subtracts the two estimates from each other within species for the two salinities (and runs a pairwise test). Our research question is: Are there different rates of reduction BETWEEN species at different salinity levels? We can use a pairwise comparison to answer this question. 5.1 Pairwise comparison pairs(con1, by = NULL) ## contrast estimate SE df z.ratio p.value ## (Fresh - 25 ALOC) - (Fresh - 25 PHAU) -3.54 0.775 Inf -4.574 &lt;.0001 ## (Fresh - 25 ALOC) - (Fresh - 25 SARU) -2.35 1.379 Inf -1.702 0.2043 ## (Fresh - 25 PHAU) - (Fresh - 25 SARU) 1.19 1.573 Inf 0.760 0.7278 ## ## Results are given on the log (not the response) scale. ## P value adjustment: tukey method for comparing a family of 3 estimates 5.2 Conclusions Increasing salinity reduced germination for our three species, and this reduction varied between species. Specifically, Allenrolfea occidentalis (ALOC) showed a lesser reduction in germination at a higher salinity level than Phragmites australis. This research shows promise for species selection when restoring invaded sites from seed. Often, invasive species like Phragmites grow back from seed due to the high density of remaining seeds in the seed bank; this research shows that Allenrolfea can compete with Phragmites germination at freshwater, and outpace Phragmites germination at a more saline condition. Other species, such as Salicornia rubra, experienced low germination regardless of salinity. This shoud not write off using Salicornia in future restoration experiments, but rather it leads to more questions about different dormancy breaking methods or ways to help native playa species establish in a restoration context. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
